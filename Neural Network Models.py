# -*- coding: utf-8 -*-
"""RNN_CNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XBs1Yl_6Rvyn5GPy56WVvhZRKAjB1XJw

## **Preprocessing**
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import plotly.express as px
import plotly.graph_objects as go
import tensorflow as tf
from sklearn.metrics import mean_absolute_error
from keras.models import Sequential
from keras.layers import LSTM, GRU, Conv1D, Dense
from keras.layers import Dropout, Flatten,MaxPooling1D
from keras.callbacks import ModelCheckpoint, EarlyStopping

from sklearn.preprocessing import MinMaxScaler

df = pd.read_csv('Data.csv')

date = pd.date_range(start = '2019-01-01', end = '2020-03-02')
df['Date'] = date

print("Missing values:")
print(df.isnull().sum())

df.interpolate(method='linear', inplace=True)

print("Missing values:")
print(df.isnull().sum())

fig = go.Figure()
fig.add_trace(go.Scatter(x = df['Date'], y = df['x1'], name = "x1"))
fig.add_trace(go.Scatter(x = df['Date'], y = df['x2'], name = 'x2'))
fig.add_trace(go.Scatter(x = df['Date'], y = df['y'], name = 'y'))
fig.update_layout(title = "American Airline Stock Prices")

df = df[df['Date'] != '2019-05-15']
df = df[df['Date'] != '2019-02-26']
df = df[df['Date'] != '2020-01-15']

fig = go.Figure()
fig.add_trace(go.Scatter(x = df['Date'], y = df['x1'], name = "x1"))
fig.add_trace(go.Scatter(x = df['Date'], y = df['x2'], name = 'x2'))
fig.add_trace(go.Scatter(x = df['Date'], y = df['y'], name = 'y'))
fig.update_layout(title = "American Airline Stock Prices")

data = df.drop(columns = ['Date'])

trainPortion = round(data.shape[0]*0.7)
valPortion = round(data.shape[0]*0.15)
trainData = data[:trainPortion]
valData = data[trainPortion:trainPortion + valPortion]
testData = data[trainPortion + valPortion:]
print('We have %d training, %d validation, and %d test points' %(len(trainData), len(valData), len(testData)))

fig = go.Figure()
# Add traces for x1
fig.add_trace(go.Scatter(x=df[:trainPortion]['Date'], y=df[:trainPortion]['x1'], name='Train Set', mode='lines', line=dict(color='blue')))
fig.add_trace(go.Scatter(x=df[trainPortion:trainPortion+valPortion]['Date'], y=df[trainPortion:trainPortion+valPortion]['x1'], name='Validation Set', mode='lines', line=dict(color='green')))
fig.add_trace(go.Scatter(x=df[trainPortion+valPortion:]['Date'], y=df[trainPortion+valPortion:]['x1'], name='Test Set', mode='lines', line=dict(color='red')))

# Add traces for x2
fig.add_trace(go.Scatter(x=df[:trainPortion]['Date'], y=df[:trainPortion]['x2'], name='Train Set', mode='lines', line=dict(color='blue')))
fig.add_trace(go.Scatter(x=df[trainPortion:trainPortion+valPortion]['Date'], y=df[trainPortion:trainPortion+valPortion]['x2'], name='Validation Set', mode='lines', line=dict(color='green')))
fig.add_trace(go.Scatter(x=df[trainPortion+valPortion:]['Date'], y=df[trainPortion+valPortion:]['x2'], name='Test Set', mode='lines', line=dict(color='red')))

sc = MinMaxScaler(feature_range=(0, 1))
sc.fit(trainData)
trainNorm = sc.transform(trainData)
valNorm = sc.transform(valData)
testNorm = sc.transform(testData)

"""## **Feedforward neural network**"""

def createSeq(dataset, look_back, foresight):
    X, Y = [], []
    for i in range(len(dataset)-look_back-foresight):
        obs = dataset[i:(i+look_back), :2] #Sequence of "look_back"
        X.append(obs)                   #Append stock price value occurring "foresight+1"
        Y.append(dataset[i + (look_back+foresight), 2])
    return np.array(X), np.array(Y)

trainNormX, trainNormY = createSeq(trainNorm, look_back = 8, foresight = 2)
print(trainNormX.shape, trainNormY.shape)

valNormX, valNormY = createSeq(valNorm, look_back = 8, foresight = 2)
testNormX, testNormY = createSeq(testNorm, look_back = 8, foresight = 2)

model = Sequential([
    Flatten(input_shape = (8,2)),
    Dense(64, activation='relu', input_shape=(8,2)),
    Dense(32, activation='relu'),
    Dense(1)
])
model.compile(loss='mae', optimizer='adam', metrics =['mean_absolute_error'])
model.summary()

# network_name = 'lstm'
# filepath = network_name + "_epoch-{epoch:02d}-loss-{loss:.4f}-.hdf5"
#checkpoint = ModelCheckpoint(filepath, monitor='loss', verbose=1, save_best_only=True, mode='min')
checkpoint = EarlyStopping(monitor='val_loss',patience=5, verbose=1, mode='auto', restore_best_weights=True)
callbacks_list = [checkpoint]
network = model.fit(trainNormX, trainNormY, validation_data=(valNormX, valNormY),
                    epochs=100, batch_size=64,callbacks=callbacks_list)

Y = np.array(testData['y'])
Y = Y.reshape(-1,1)

testNormPred= model.predict(testNormX)
sc.fit(Y)
testPred = sc.inverse_transform(testNormPred.reshape(-1, 1))
testY = sc.inverse_transform(testNormY.reshape(-1,1))
testMae = mean_absolute_error(testY, testPred)

fig = go.Figure()
fig.add_trace(go.Scatter(y=testPred.reshape(-1,),
                    mode='markers',
                    name='Model Predictions on Test Set'))
fig.add_trace(go.Scatter(y=testY.reshape(-1,),
                    mode='markers',
                    name='Target Values for the Test Set'))
fig.update_layout(title_text='Unnormalized MAE Test = '
                  + str(np.mean(testMae)))
fig.show()

plt.plot(network.history['loss'], label='train loss')
plt.plot(network.history['val_loss'], label='val loss')
plt.legend()
plt.show()

print("The predicted values of y for March 1st is:{:.2f}\nThe predicted values of y for March 2nd is:{:.2f}".format(testPred[-2][0], testPred[-1][0]))

"""# **LSTM**"""

def createSeq(dataset, look_back, foresight):
    X, Y = [], []
    for i in range(len(dataset)-look_back-foresight):
        obs = dataset[i:(i+look_back), :2] #Sequence of "look_back"
        X.append(obs)                   #Append stock price value occurring "foresight+1"
        Y.append(dataset[i + (look_back+foresight), 2])
    return np.array(X), np.array(Y)

trainNormX, trainNormY = createSeq(trainNorm, look_back = 8, foresight = 2)
print(trainNormX.shape, trainNormY.shape)

valNormX, valNormY = createSeq(valNorm, look_back = 8, foresight = 2)
testNormX, testNormY = createSeq(testNorm, look_back = 8, foresight = 2)

model = Sequential()
model.add(LSTM(32,  input_shape=(8,2), dropout=0.1, recurrent_dropout=0.1))
model.add(Dense(1, activation='linear'))
model.compile(loss='mae', optimizer='adam', metrics =['mean_absolute_error'])
model.summary()

# network_name = 'lstm'
# filepath = network_name + "_epoch-{epoch:02d}-loss-{loss:.4f}-.hdf5"
#checkpoint = ModelCheckpoint(filepath, monitor='loss', verbose=1, save_best_only=True, mode='min')
checkpoint = EarlyStopping(monitor='val_loss',patience=5, verbose=1, mode='auto', restore_best_weights=True)
callbacks_list = [checkpoint]
network = model.fit(trainNormX, trainNormY, validation_data=(valNormX, valNormY),
                    epochs=100, batch_size=64,callbacks=callbacks_list)

Y = np.array(testData['y'])
Y = Y.reshape(-1,1)

testNormPred= model.predict(testNormX)
sc.fit(Y)
testPred = sc.inverse_transform(testNormPred.reshape(-1, 1))
testY = sc.inverse_transform(testNormY.reshape(-1,1))
testMae = mean_absolute_error(testY, testPred)

fig = go.Figure()
fig.add_trace(go.Scatter(y=testPred.reshape(-1,),
                    mode='markers',
                    name='Model Predictions on Test Set'))
fig.add_trace(go.Scatter(y=testY.reshape(-1,),
                    mode='markers',
                    name='Target Values for the Test Set'))
fig.update_layout(title_text='Unnormalized MAE Test = '
                  + str(np.mean(testMae)))
fig.show()

plt.plot(network.history['loss'], label='train loss')
plt.plot(network.history['val_loss'], label='val loss')
plt.legend()
plt.show()

print("The predicted values of y for March 1st is:{:.2f}\nThe predicted values of y for March 2nd is:{:.2f}".format(testPred[-2][0], testPred[-1][0]))

"""# **GRU**"""

def createSeq(dataset, look_back, foresight):
    X, Y = [], []
    for i in range(len(dataset)-look_back-foresight):
        obs = dataset[i:(i+look_back), :2] #Sequence of "look_back"
        X.append(obs)                   #Append stock price value occurring "foresight+1"
        Y.append(dataset[i + (look_back+foresight), 2])
    return np.array(X), np.array(Y)

trainNormX, trainNormY = createSeq(trainNorm, look_back = 8, foresight = 2)
print(trainNormX.shape, trainNormY.shape)

valNormX, valNormY = createSeq(valNorm, look_back = 8, foresight = 2)
testNormX, testNormY = createSeq(testNorm, look_back = 8, foresight = 2)

model = Sequential()
model.add(GRU(32,  input_shape=(8,2), dropout=0.1, recurrent_dropout=0.1))
model.add(Dense(1, activation='linear'))
model.compile(loss='mae', optimizer='adam', metrics =['mean_absolute_error'])
model.summary()

# network_name = 'lstm'
# filepath = network_name + "_epoch-{epoch:02d}-loss-{loss:.4f}-.hdf5"
#checkpoint = ModelCheckpoint(filepath, monitor='loss', verbose=1, save_best_only=True, mode='min')
checkpoint = EarlyStopping(monitor='val_loss',patience=5, verbose=1, mode='auto', restore_best_weights=True)
callbacks_list = [checkpoint]
network = model.fit(trainNormX, trainNormY, validation_data=(valNormX, valNormY),
                    epochs=100, batch_size=64,callbacks=callbacks_list)

Y = np.array(testData['y'])
Y = Y.reshape(-1,1)

testNormPred= model.predict(testNormX)
sc.fit(Y)
testPred = sc.inverse_transform(testNormPred.reshape(-1, 1))
testY = sc.inverse_transform(testNormY.reshape(-1,1))
testMae = mean_absolute_error(testY, testPred)

fig = go.Figure()
fig.add_trace(go.Scatter(y=testPred.reshape(-1,),
                    mode='markers',
                    name='Model Predictions on Test Set'))
fig.add_trace(go.Scatter(y=testY.reshape(-1,),
                    mode='markers',
                    name='Target Values for the Test Set'))
fig.update_layout(title_text='Unnormalized MAE Test = '
                  + str(np.mean(testMae)))
fig.show()

plt.plot(network.history['loss'], label='train loss')
plt.plot(network.history['val_loss'], label='val loss')
plt.legend()
plt.show()

print("The predicted values of y for March 1st is:{:.2f}\nThe predicted values of y for March 2nd is:{:.2f}".format(testPred[-2][0], testPred[-1][0]))

"""# **Conv 1D**"""

def createSeq(dataset, look_back, foresight):
    X, Y = [], []
    for i in range(len(dataset)-look_back-foresight):
        obs = dataset[i:(i+look_back), :2] #Sequence of "look_back"
        X.append(obs)                   #Append stock price value occurring "foresight+1"
        Y.append(dataset[i + (look_back+foresight), 2])
    return np.array(X), np.array(Y)

trainNormX, trainNormY = createSeq(trainNorm, look_back = 8, foresight = 2)
print(trainNormX.shape, trainNormY.shape)

valNormX, valNormY = createSeq(valNorm, look_back = 8, foresight = 2)
testNormX, testNormY = createSeq(testNorm, look_back = 8, foresight = 2)

model = Sequential()
model.add(Conv1D(64, kernel_size=5, input_shape=(8,2), activation='relu'))
model.add(MaxPooling1D(pool_size = 2))
model.add(MaxPooling1D(pool_size = 2))
model.add(Dense(1, activation='linear'))
model.compile(loss='mae', optimizer='adam', metrics =['mean_absolute_error'])
model.summary()

# network_name = 'lstm'
# filepath = network_name + "_epoch-{epoch:02d}-loss-{loss:.4f}-.hdf5"
#checkpoint = ModelCheckpoint(filepath, monitor='loss', verbose=1, save_best_only=True, mode='min')
checkpoint = EarlyStopping(monitor='val_loss',patience=5, verbose=1, mode='auto', restore_best_weights=True)
callbacks_list = [checkpoint]
network = model.fit(trainNormX, trainNormY, validation_data=(valNormX, valNormY),
                    epochs=100, batch_size=64,callbacks=callbacks_list)

testNormPred= model.predict(testNormX)
sc.fit(Y)
testPred = sc.inverse_transform(testNormPred.reshape(-1, 1))
testY = sc.inverse_transform(testNormY.reshape(-1,1))
testMae = mean_absolute_error(testY, testPred)

fig = go.Figure()
fig.add_trace(go.Scatter(y=testPred.reshape(-1,),
                    mode='markers',
                    name='Model Predictions on Test Set'))
fig.add_trace(go.Scatter(y=testY.reshape(-1,),
                    mode='markers',
                    name='Target Values for the Test Set'))
fig.update_layout(title_text='Unnormalized MAE Test = '
                  + str(np.mean(testMae)))
fig.show()

plt.plot(network.history['loss'], label='train loss')
plt.plot(network.history['val_loss'], label='val loss')
plt.legend()
plt.show()

print("The predicted values of y for March 1st is:{:.2f}\nThe predicted values of y for March 2nd is:{:.2f}".format(testPred[-2][0], testPred[-1][0]))